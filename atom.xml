<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FsBlog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ferlysky.gitee.io/"/>
  <updated>2019-05-08T05:56:02.061Z</updated>
  <id>https://ferlysky.gitee.io/</id>
  
  <author>
    <name>FerlySky</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python Spider 2: 网络请求</title>
    <link href="https://ferlysky.gitee.io/python-spider-2.html"/>
    <id>https://ferlysky.gitee.io/python-spider-2.html</id>
    <published>2019-04-08T13:59:47.000Z</published>
    <updated>2019-05-08T05:56:02.061Z</updated>
    
    <content type="html"><![CDATA[<p>要想分析到有用的数据，我们首先要先获取到网络资源，其中最主要的就是网页和json</p><p>浏览器在获取资源时，实际上是向浏览器发送了http请求</p><p>这一章中我们会了解如何手动发送http请求获取资源，以及如何用已有的框架（requests）获取资源</p><a id="more"></a><h1 id="建立Tcp连接模拟Http请求"><a href="#建立Tcp连接模拟Http请求" class="headerlink" title="建立Tcp连接模拟Http请求"></a>建立Tcp连接模拟Http请求</h1><p>http请求的本质是一个tcp请求，只是传输数据的格式比较特殊。</p><h2 id="Http请求报文解析"><a href="#Http请求报文解析" class="headerlink" title="Http请求报文解析"></a>Http请求报文解析</h2><p>http请求报文由3部分组成：请求行，请求头，请求体。其中某些请求方式可能没有请求体。</p><p>下面是一个http post的请求报文：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/weapi/search/suggest/web?csrf_token=</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: music.163.com</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">Content-Length</span>: 394</span><br><span class="line"><span class="attribute">Pragma</span>: no-cache</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-cache</span><br><span class="line"><span class="attribute">Origin</span>: https://music.163.com</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Accept</span>: */*</span><br><span class="line"><span class="attribute">Referer</span>: https://music.163.com/</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate, br</span><br><span class="line"><span class="attribute">Accept-Language</span>: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7</span><br><span class="line"><span class="attribute">Cookie</span>: starttime=;</span><br><span class="line"></span><br><span class="line">params=tZA39GIzuYfZGwabdxUe3OtRtEj8BqfGyk95pyloHT3iIsxUfDmEC60V1rxn0DHfvKVnXrACICP6ZV7a8wQC74RO%2BHPxDM%2FlwiYU%2B%2BwS%2Bf8%3D&amp;encSecKey=8bf98f9a88662ac9606ff2c9336a23f6d9e7413cb3c6c9c2ef56eeec2e814ead675a032c9905b21526bd8ed59aa0862d0114d78629f954f47276cb3f2a9987faf49add6b5c289776c23329cada89afbb51e6e5c756c637be364a695013c1029da680894766a234656a667991cd580c8cd047160de48e0ff9982437826d374524</span><br></pre></td></tr></table></figure></p><p>第一行为请求行：<code>POST /weapi/search/suggest/web?csrf_token= HTTP/1.1</code>，由三部分组成，请求方式，请求路径和协议版本</p><ul><li>请求方式：爬虫最常见的请求方式为GET方式和POST方式，除此之外还有DELETE，PUT，HEAD等</li><li>请求路径：请求路径是一个uri，是相对服务器项目根路径下的地址</li><li>协议版本：HTTP1.0和HTTP1.1，其中1.0每完成一次请求都会断开连接，而HTTP1.1会保持连接一段时间</li></ul><p>从第二行开始，到空行结束的部分为请求头。表示请求时的一些请求通用参数，它的本质为一个Map，其中请求头的key有固定的含义，不区分大小写</p><p>第三部分为请求体，不同的请求类型，请求体的格式也不同，常见为key-value形式，用于表示参数，key和value之间用’=’连接，参数之间用’&amp;’连接</p><p>注意请求头和请求体之间有一个空行，请求体结束也需要一个空行</p><h2 id="Http响应报文解析"><a href="#Http响应报文解析" class="headerlink" title="Http响应报文解析"></a>Http响应报文解析</h2><p>响应报文和请求报文一样，由响应行，响应头和响应体组成<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Accept-Ranges</span>: bytes</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-cache</span><br><span class="line"><span class="attribute">Content-Length</span>: 14615</span><br><span class="line"><span class="attribute">Content-Type</span>: text/html</span><br><span class="line"><span class="attribute">Date</span>: Mon, 15 Apr 2019 10:34:52 GMT</span><br><span class="line"><span class="attribute">Etag</span>: "5c9c7bd5-3917"</span><br><span class="line"><span class="attribute">Last-Modified</span>: Thu, 28 Mar 2019 07:46:29 GMT</span><br><span class="line"><span class="attribute">P3p</span>: CP=" OTI DSP COR IVA OUR IND COM "</span><br><span class="line"><span class="attribute">Pragma</span>: no-cache</span><br><span class="line"><span class="attribute">Server</span>: BWS/1.1</span><br><span class="line"><span class="attribute">Set-Cookie</span>: BAIDUID=71A25E6D0916916E940A4FCA7B0D87C6:FG=1; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com</span><br><span class="line"><span class="attribute">Set-Cookie</span>: BIDUPSID=71A25E6D0916916E940A4FCA7B0D87C6; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com</span><br><span class="line"><span class="attribute">Set-Cookie</span>: PSTM=1555324492; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com</span><br><span class="line"><span class="attribute">Vary</span>: Accept-Encoding</span><br><span class="line"><span class="attribute">X-Ua-Compatible</span>: IE=Edge,chrome=1</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;</span><br><span class="line">&lt;meta http-equiv="X-UA-Compatible" content="IE=Edge"&gt;</span><br><span class="line">&lt;link rel="dns-prefetch" href="//s1.bdstatic.com"/&gt;</span><br></pre></td></tr></table></figure></p><p>响应行由三部分组成，协议版本，响应状态码，响应消息。其中响应消息和相应状态码通常相对应</p><p>HTTP状态码分类：</p><table><thead><tr><th>分类</th><th>分类描述</th></tr></thead><tbody><tr><td>1xx</td><td>表示服务器收到了请求，需要请求者继续发送请求</td></tr><tr><td>2xx</td><td>表示操作成功</td></tr><tr><td>3xx</td><td>重定向，表示需要进一步操作</td></tr><tr><td>4xx</td><td>客户端错误，表示语法错误或无法完成请求</td></tr><tr><td>5xx</td><td>服务端错误，表示服务器在处理请求的过程中发生了错误</td></tr></tbody></table><p>常见的状态码：</p><table><thead><tr><th>状态码</th><th>消息</th><th>描述</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td>请求成功</td></tr><tr><td>302</td><td>REDIRECT</td><td>暂时的重定向</td></tr><tr><td>400</td><td>BAD REQUEST</td><td>请求错误</td></tr><tr><td>404</td><td>NOT FOUND</td><td>资源未找到</td></tr><tr><td>500</td><td>Internal Server Error</td><td>服务器错误</td></tr></tbody></table><p>响应头与请求头一样，都是有固定一样的键值参数</p><p>响应体就是与我们请求时的uri和参数的资源啦。</p><h2 id="使用python发送http请求"><a href="#使用python发送http请求" class="headerlink" title="使用python发送http请求"></a>使用python发送http请求</h2><p>我们这里以请求百度的主页为例，看一下如何使用tcp来发送http请求<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  <span class="comment"># 创建socket对象</span></span><br><span class="line">    client.connect((<span class="string">'www.baidu.com'</span>, <span class="number">80</span>))  <span class="comment"># 连接百度服务器，http请求默认为80端口</span></span><br><span class="line">    request_line = <span class="string">'GET / HTTP/1.0'</span>  <span class="comment"># 请求行</span></span><br><span class="line">    request_header = <span class="string">'HOST: www.baidu.com'</span>  <span class="comment"># 请求头</span></span><br><span class="line">    request_body = <span class="string">''</span>  <span class="comment"># 请求体</span></span><br><span class="line">    <span class="comment"># 拼接请求字符串</span></span><br><span class="line">    <span class="keyword">if</span> len(request_body) &gt; <span class="number">0</span>:</span><br><span class="line">        request_text = <span class="string">'\r\n'</span>.join([request_line, request_header, request_body, <span class="string">''</span>]) + <span class="string">'\r\n'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        request_text = <span class="string">'\r\n'</span>.join([request_line, request_header]) + <span class="string">'\r\n\r\n'</span></span><br><span class="line">    print(request_text)  <span class="comment"># 输出请求报文</span></span><br><span class="line">    client.send(request_text.encode())  <span class="comment"># 发送请求报文</span></span><br><span class="line">    print(<span class="string">'*'</span> * <span class="number">150</span>)  <span class="comment"># 分割线</span></span><br><span class="line">    <span class="comment"># 获取相应报文</span></span><br><span class="line">    data = <span class="string">b''</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        rec_data = client.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> rec_data:</span><br><span class="line">            data += rec_data</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    print(data.decode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure></p><p><img src="https://raw.githubusercontent.com/FerlySky/PicRepository/master/20190508135516.png" alt="Tcp请求结果"></p><h2 id="Tcp方式的缺点"><a href="#Tcp方式的缺点" class="headerlink" title="Tcp方式的缺点"></a>Tcp方式的缺点</h2><p>在实际爬虫或其他http请求需求的时候，我们很少会用tcp方式发送http请求，因为它有很多缺点</p><ul><li>需要手动构建请求路径uri，手动构建uri的请求参数，并且在需要时进行url编码</li><li>需要手动拼接请求头</li><li>传递参数或者上传文件（图片）等资源时需要手动处理</li><li>解析响应报文非常复杂且容易出错</li><li>很难使用代理服务器发送请求</li></ul><h1 id="requests"><a href="#requests" class="headerlink" title="requests"></a>requests</h1><p>由于Tcp发送http请求的方式有很多缺点，所以我们通常会使用一些http请求的框架来帮我们解决这些问题。而在python中，最常见的http请求库就是requests</p><p>由于requests是第三方库，所以我们在使用requests之前，需要先安装它：<code>pip install requests</code></p><p>引入requests：<code>import requests</code></p><p>快速入门：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    resp = requests.get(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line">    print(resp.text)</span><br></pre></td></tr></table></figure></p><h2 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h2><p>发送不同的请求方式的请求，可以直接调用对应的方法即可<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">response = requests.get(<span class="string">'https://api.github.com/events'</span>)</span><br><span class="line">response = requests.post(<span class="string">'http://httpbin.org/post'</span>, data = &#123;<span class="string">'key'</span>:<span class="string">'value'</span>&#125;)</span><br><span class="line">response = requests.put(<span class="string">'http://httpbin.org/put'</span>, data = &#123;<span class="string">'key'</span>:<span class="string">'value'</span>&#125;)</span><br><span class="line">response = requests.delete(<span class="string">'http://httpbin.org/delete'</span>)</span><br><span class="line">response = requests.head(<span class="string">'http://httpbin.org/get'</span>)</span><br><span class="line">response = requests.options(<span class="string">'http://httpbin.org/get'</span>)</span><br></pre></td></tr></table></figure></p><p>由于post和put方法往往需要传递参数，可以直接传递data这个命名参数，类型为map类型</p><h3 id="url参数"><a href="#url参数" class="headerlink" title="url参数"></a>url参数</h3><p>有些时候我们需要在通过url传递参数，我们可以使用params参数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">params = &#123;</span><br><span class="line">    <span class="string">'ie'</span>: <span class="string">'UTF-8'</span>,</span><br><span class="line">    <span class="string">'word'</span>: <span class="string">'test'</span></span><br><span class="line">&#125;</span><br><span class="line">url = <span class="string">'https://www.baidu.com/s'</span></span><br><span class="line">response = requests.get(url,params=params)</span><br></pre></td></tr></table></figure></p><p>这时，我们get的真实url为：<code>https://www.baidu.com/s?ie=UTF-8&amp;wd=test</code></p><h3 id="自定义请求头"><a href="#自定义请求头" class="headerlink" title="自定义请求头"></a>自定义请求头</h3><p>在请求的时候，我们往往需要模拟Host或Origin请求头来进行模拟跨域操作，需要使用到headers<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'Accept'</span>: <span class="string">'*/*'</span>,</span><br><span class="line">    <span class="string">'Host'</span>: <span class="string">'www.baidu.com'</span></span><br><span class="line">&#125;</span><br><span class="line">url = <span class="string">'https://www.baidu.com/'</span></span><br><span class="line">response = requests.get(url, headers=headers)</span><br></pre></td></tr></table></figure></p><h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><p>有些时候我们可能需要上传某些文件，比如修改头像等，我们可以使用files参数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">files = &#123;<span class="string">'file'</span>: open(<span class="string">'avatar.png'</span>, <span class="string">'rb'</span>)&#125;</span><br><span class="line">url = <span class="string">'http://httpbin.org/post'</span></span><br><span class="line">response = requests.post(url, files=files)</span><br></pre></td></tr></table></figure></p><h2 id="获取响应"><a href="#获取响应" class="headerlink" title="获取响应"></a>获取响应</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'text'</span>, response.text)  <span class="comment"># 获取响应文本，类型为str</span></span><br><span class="line">print(<span class="string">'content'</span>, response.content)  <span class="comment"># 获取响应内容，类型为bytes</span></span><br><span class="line">print(<span class="string">'json'</span>, response.json())  <span class="comment"># 将响应内容当作json字符串解析</span></span><br><span class="line">print(<span class="string">'status code'</span>, response.status_code)  <span class="comment"># 获取响应状态码</span></span><br><span class="line">print(<span class="string">'encoding'</span>, response.encoding)  <span class="comment"># 获取编码格式</span></span><br><span class="line">print(<span class="string">'headers'</span>, response.headers)  <span class="comment"># 获取响应头</span></span><br></pre></td></tr></table></figure><p>修改响应编码格式：<code>response.encoding = &#39;UTF-8&#39;</code>，先修改完编码格式，在通过<code>response.text</code>即可获取UTF-8（或其他）编码格式下的响应文本</p><h2 id="流式请求"><a href="#流式请求" class="headerlink" title="流式请求"></a>流式请求</h2><p>有时我们请求的资源不一定都是文本类型，有可能是图片，视频，音乐等文件类型，这些文件通常比较大，虽然可以使用上面的普通方式，通过<code>response.content</code>获取二进制字符集，但是我们使用数据流的方式能更方便的处理大型文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chunk_size = <span class="number">1024</span> * <span class="number">16</span>  <span class="comment"># 声明数据块大小</span></span><br><span class="line">response = requests.get(<span class="string">'https://ferlysky.gitee.io/images/avatar.png'</span>, stream=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'avatar.png'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># 迭代数据块，并写入到文件中</span></span><br><span class="line">    <span class="keyword">for</span> chunk <span class="keyword">in</span> response.iter_content(chunk_size):</span><br><span class="line">        f.write(chunk)</span><br></pre></td></tr></table></figure><p>这里用到了文件io，我会在后面的章节进行讲解</p><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>爬虫时，我们往往会被网站的反爬机制限制ip访问，这时我们可以使用代理服务器来解决</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">proxies = &#123;</span><br><span class="line">    <span class="string">"http"</span>: <span class="string">"http://10.10.1.10:3128"</span>,</span><br><span class="line">    <span class="string">"https"</span>: <span class="string">"http://10.10.1.10:1080"</span>,</span><br><span class="line">&#125;</span><br><span class="line">requests.get(<span class="string">"http://example.org"</span>, proxies=proxies)</span><br></pre></td></tr></table></figure><h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>在我们进行请求的时候，有时需要我们传递cookies(例如登录之后才能进行的操作)</p><h3 id="手动cookies"><a href="#手动cookies" class="headerlink" title="手动cookies"></a>手动cookies</h3><p>请求时携带cookies<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jar = requests.cookies.RequestsCookieJar()</span><br><span class="line">jar.set(<span class="string">'name'</span>, <span class="string">'FerlySky'</span>)</span><br><span class="line">jar.set(<span class="string">'url'</span>, <span class="string">'https://ferlysky.gitee.io'</span>)</span><br><span class="line">url = <span class="string">'http://httpbin.org/cookies'</span></span><br><span class="line">response = requests.get(url, cookies=jar)</span><br><span class="line">print(response.json())</span><br></pre></td></tr></table></figure></p><p>获取响应cookies<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'cookies'</span>, response.cookies)</span><br></pre></td></tr></table></figure></p><h3 id="自动携带cookies"><a href="#自动携带cookies" class="headerlink" title="自动携带cookies"></a>自动携带cookies</h3><p>每次都需要手动设置cookies，并且把响应的cookies拿出来再次设置到下次请求中实在是太麻烦了，requests库给我们提供了一种简单的方法，就是使用session对象</p><p>使用session对象，可以将我们上一次请求时响应的cookies保存下来，在下一次请求时发送出去</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">session = requests.session()</span><br><span class="line"></span><br><span class="line">response = session.get(<span class="string">'http://www.baidu.com/'</span>)</span><br><span class="line">print(response.cookies[<span class="string">'BDORZ'</span>])</span><br></pre></td></tr></table></figure><p>session的操作和requests几乎完全一致</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;要想分析到有用的数据，我们首先要先获取到网络资源，其中最主要的就是网页和json&lt;/p&gt;
&lt;p&gt;浏览器在获取资源时，实际上是向浏览器发送了http请求&lt;/p&gt;
&lt;p&gt;这一章中我们会了解如何手动发送http请求获取资源，以及如何用已有的框架（requests）获取资源&lt;/p&gt;
    
    </summary>
    
      <category term="网络爬虫" scheme="https://ferlysky.gitee.io/categories/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="python" scheme="https://ferlysky.gitee.io/tags/python/"/>
    
      <category term="spider" scheme="https://ferlysky.gitee.io/tags/spider/"/>
    
      <category term="网络爬虫" scheme="https://ferlysky.gitee.io/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    
      <category term="网络请求" scheme="https://ferlysky.gitee.io/tags/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
    
      <category term="http" scheme="https://ferlysky.gitee.io/tags/http/"/>
    
      <category term="requests" scheme="https://ferlysky.gitee.io/tags/requests/"/>
    
      <category term="tcp" scheme="https://ferlysky.gitee.io/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>Python Spider 1: 概述</title>
    <link href="https://ferlysky.gitee.io/python-spider-1.html"/>
    <id>https://ferlysky.gitee.io/python-spider-1.html</id>
    <published>2019-04-07T14:07:09.000Z</published>
    <updated>2019-04-18T14:14:27.455Z</updated>
    
    <content type="html"><![CDATA[<p>随着大数据时代的到来，人们对数据资源的需求越来越多，而爬虫是一种很好的自动采集数据的手段。</p><h1 id="网络爬虫"><a href="#网络爬虫" class="headerlink" title="网络爬虫"></a>网络爬虫</h1><blockquote><p>网络爬虫（又被称为网页蜘蛛，网络机器人，在FOAF社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。</p></blockquote><a id="more"></a><h1 id="爬虫的分类及应用"><a href="#爬虫的分类及应用" class="headerlink" title="爬虫的分类及应用"></a>爬虫的分类及应用</h1><p>爬虫按照系统结构和实现技术大致可以分为：通用网络爬虫、聚焦网络爬虫 、增量式网络爬虫和深层网络爬虫。</p><ul><li>通用网络爬虫：通用爬虫的目标是尽可能大的网络覆盖。由于其数据涵盖范围较广，很多时候并不能获取到比较专业的资源。像百度谷歌等搜索引擎就是典型的通用爬虫。</li><li>聚焦网络爬虫：它根据要爬取的目标，有选择性的获取互联网上的资源，其结果更具有针对性。</li><li>增量式网络爬虫：只爬取新产生的或者发生变化的网页，不爬取已经获取过的资源。可以减小时间、空间以及带宽的消耗，但是实现起来相对复杂</li><li>深层网络爬虫：爬取某些非表面显示的资源，比如需要登录账号才能查看的资源。</li></ul><h1 id="爬虫的工作流程"><a href="#爬虫的工作流程" class="headerlink" title="爬虫的工作流程"></a>爬虫的工作流程</h1><ol><li>首先选取一部分精心挑选的种子URL；</li><li>将这些URL放入待抓取URL队列；</li><li>从待抓取URL队列中取出待抓取在URL，解析DNS，并且得到主机的ip，并将URL对应的网页下载下来，存储进已下载网页库中。此外，将这些URL放进已抓取URL队列。</li><li>分析已抓取URL队列中的URL，分析其中的其他URL，并且将URL放入待抓取URL队列，从而进入下一个循环。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着大数据时代的到来，人们对数据资源的需求越来越多，而爬虫是一种很好的自动采集数据的手段。&lt;/p&gt;
&lt;h1 id=&quot;网络爬虫&quot;&gt;&lt;a href=&quot;#网络爬虫&quot; class=&quot;headerlink&quot; title=&quot;网络爬虫&quot;&gt;&lt;/a&gt;网络爬虫&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;网络爬虫（又被称为网页蜘蛛，网络机器人，在FOAF社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="网络爬虫" scheme="https://ferlysky.gitee.io/categories/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="python" scheme="https://ferlysky.gitee.io/tags/python/"/>
    
      <category term="spider" scheme="https://ferlysky.gitee.io/tags/spider/"/>
    
      <category term="网络爬虫" scheme="https://ferlysky.gitee.io/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    
      <category term="概述" scheme="https://ferlysky.gitee.io/tags/%E6%A6%82%E8%BF%B0/"/>
    
  </entry>
  
  <entry>
    <title>算法 1: 动态规划</title>
    <link href="https://ferlysky.gitee.io/algorithm-1.html"/>
    <id>https://ferlysky.gitee.io/algorithm-1.html</id>
    <published>2019-03-29T14:22:16.000Z</published>
    <updated>2019-05-08T05:59:03.483Z</updated>
    
    <content type="html"><![CDATA[<p>动态规划是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。</p><p>动态规划常常适用于有重叠子问题和最优子结构性质的问题。<br><a id="more"></a></p><h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><p>若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。</p><p>动态规划的核心是：<strong>记忆已经解决的子问题的解</strong></p><h1 id="问题特征"><a href="#问题特征" class="headerlink" title="问题特征"></a>问题特征</h1><p>动态规划的基本特征：问题的最优解需要使用到其子问题的最优解</p><h1 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h1><ol><li>分析最优解的结构：将问题划分成两个子问题，如果原问题获得最优解，子问题也应该是最优解。</li><li>建立递推关系</li><li>计算最优解</li></ol><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="最长回文子串问题"><a href="#最长回文子串问题" class="headerlink" title="最长回文子串问题"></a>最长回文子串问题</h2><ol><li>问题：给定一个字符串s，找到s中最长的回文子串。（选自Leetcode #5）</li><li>分析解结构：<br> 如果一个字符串是回文串，那么它去掉收尾后也应该是回文串。那么我们就可以讲问题转化为先找到一个小的回文串，然后在判断该回文串在原字符串中前后两个字符是否相同，如果相同，将该子回文串的前后都添加这个字符，新的字符串仍是回文串。</li><li><p>建立递推关系：<br> 设 i, j为字符串s的某一子字符串s[i:j]的开始索引和结束索引，i &lt;= j，我们可以使用一个二维的bool数组 b 来记录位置 b[i][j] 对应的子字符串 s[i:j] 是否为回文串。</p><ol><li>如果 i == j, 说明s[i:j]为单个字符，必定是一个回文串</li><li>如果 j - i == 1, 说明s[i:j]是一个长度为2的字符串，如果 s[i] == s[j], 则s[i:j]是一个回文串</li><li><p>如果 i, j 不满足前两条，说明s[i:j]是一个长度大于等于3的字符串，它可以由它去掉两端的字串s[i+1:j-1]，拼接两个字符 s[i], s[j] 来解决，如果 s[i+1:j-1] 是一个回文串，同时 s[i] == s[j], 则s[i:j]是一个回文串</p><p>用公式表示为：<br><img src="https://raw.githubusercontent.com/FerlySky/PicRepository/master/20190508135847.png" alt="最长回文子串问题公式表示"></p><p>我们以 s = “atrattardd” 为例，画出二维数组：<br><img src="https://raw.githubusercontent.com/FerlySky/PicRepository/master/20190508135817.png" alt="最长回文子串问题示例矩阵"></p><p>我们可以清晰的发现，如果一个位置为0，那么它右上方的位置一定为0，并且要获取最长回文子串，只需要找到矩阵中，离右上角最近的1的位置即可。对于该示例而言，最长回文子串的位置为s[2:7] = “rattar”</p></li></ol></li><li>算法实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="comment">// 用来记录对应子串是否为回文子串</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] bmap = <span class="keyword">new</span> <span class="keyword">boolean</span>[length][length];</span><br><span class="line">        <span class="comment">// 用来记录长度的最大值</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 为了保证在计算某一位置之前，其最下方位置已经被计算并保存过，所以这里i从下往上遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &lt; length; j++) &#123; <span class="comment">// &amp;&amp; j &lt; length</span></span><br><span class="line">                <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                    bmap[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j - i == <span class="number">1</span>) &#123;</span><br><span class="line">                    bmap[i][j] = chars[i] == chars[j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    bmap[i][j] = bmap[i+<span class="number">1</span>][j-<span class="number">1</span>] &amp;&amp; chars[i] == chars[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (bmap[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; max) &#123;</span><br><span class="line">                    max = j - i + <span class="number">1</span>;</span><br><span class="line">                    start = i;</span><br><span class="line">                    end = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start, end + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;动态规划是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。&lt;/p&gt;
&lt;p&gt;动态规划常常适用于有重叠子问题和最优子结构性质的问题。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="https://ferlysky.gitee.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="algorithm" scheme="https://ferlysky.gitee.io/tags/algorithm/"/>
    
      <category term="算法" scheme="https://ferlysky.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="https://ferlysky.gitee.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Flutter Plugins 1: Fluttertoast</title>
    <link href="https://ferlysky.gitee.io/flutter-plugin-1.html"/>
    <id>https://ferlysky.gitee.io/flutter-plugin-1.html</id>
    <published>2019-03-28T04:31:45.000Z</published>
    <updated>2019-04-18T14:14:27.455Z</updated>
    
    <content type="html"><![CDATA[<p>Fluttertoast 是一个弹出toast的第三方框架<br><a id="more"></a></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line"><span class="attr">  fluttertoast:</span> <span class="string">^3.0.3</span></span><br></pre></td></tr></table></figure><p>获取最新版本号：<a href="https://pub.flutter-io.cn/packages/fluttertoast" rel="external nofollow noopener noreferrer" target="_blank">https://pub.flutter-io.cn/packages/fluttertoast</a></p><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><h2 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:fluttertoast/fluttertoast'</span>;</span><br></pre></td></tr></table></figure><h2 id="弹出toast"><a href="#弹出toast" class="headerlink" title="弹出toast"></a>弹出toast</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Fluttertoast.showToast(</span><br><span class="line">  msg: <span class="string">"This is Center Short Toast"</span>,</span><br><span class="line">  toastLength: Toast.LENGTH_SHORT,</span><br><span class="line">  gravity: ToastGravity.CENTER,</span><br><span class="line">  timeInSecForIos: <span class="number">1</span>,</span><br><span class="line">  backgroundColor: Colors.red,</span><br><span class="line">  textColor: Colors.white,</span><br><span class="line">  fontSize: <span class="number">16.0</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>参数:</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>msg</td><td>String，要弹出的消息，非空必须</td></tr><tr><td>toastLength</td><td>Toast.LENGTH_SHORT、 Toast.LENGTH_LONG</td></tr><tr><td>gravity</td><td>ToastGravity，toast显示的位置，ToastGravity.TOP、ToastGravity.CENTER、ToastGravity.BOTTOM</td></tr><tr><td>timeInSecForIos</td><td>int，仅限ios平台</td></tr><tr><td>backgroundColor</td><td>Color，背景颜色</td></tr><tr><td>textColor</td><td>Color，文字颜色</td></tr><tr><td>fontSize</td><td>float，文字大小</td></tr></tbody></table><h2 id="取消弹出"><a href="#取消弹出" class="headerlink" title="取消弹出"></a>取消弹出</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fluttertoast.cancel();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Fluttertoast 是一个弹出toast的第三方框架&lt;br&gt;
    
    </summary>
    
      <category term="Flutter" scheme="https://ferlysky.gitee.io/categories/Flutter/"/>
    
      <category term="Flutter Plugins" scheme="https://ferlysky.gitee.io/categories/Flutter/Flutter-Plugins/"/>
    
    
      <category term="Flutter" scheme="https://ferlysky.gitee.io/tags/Flutter/"/>
    
      <category term="Flutter Plugin" scheme="https://ferlysky.gitee.io/tags/Flutter-Plugin/"/>
    
  </entry>
  
</feed>
