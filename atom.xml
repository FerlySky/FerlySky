<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FsBlog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ferlysky.gitee.io/"/>
  <updated>2019-05-17T09:23:42.316Z</updated>
  <id>https://ferlysky.gitee.io/</id>
  
  <author>
    <name>FerlySky</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python Spider 3：文本解析</title>
    <link href="https://ferlysky.gitee.io/python-spider-3.html"/>
    <id>https://ferlysky.gitee.io/python-spider-3.html</id>
    <published>2019-05-17T09:18:22.000Z</published>
    <updated>2019-05-17T09:23:42.316Z</updated>
    
    <content type="html"><![CDATA[<p>在上一节中，我们学会了使用requests库从网上请求数据，但是我们发现请求的数据很多时候是html页面，页面中有用的内容往往只有其中的一小部分，所以我们就需要在很大的文本（通常是html）中提取出对我们最有用的内容</p><p>在这一小节，我们会了解到如何解析json、如何使用正则表达式解析文本，以及使用xpath和css选择器解析html文档</p><a id="more"></a><h1 id="json"><a href="#json" class="headerlink" title="json"></a>json</h1><h2 id="json文本数据的格式"><a href="#json文本数据的格式" class="headerlink" title="json文本数据的格式"></a>json文本数据的格式</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"FerlySky"</span>,</span><br><span class="line">    <span class="attr">"admin"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"hobby"</span>: [<span class="string">"编程"</span>]</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"cxk"</span>,</span><br><span class="line">    <span class="attr">"admin"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"hobby"</span>: [<span class="string">"唱"</span>, <span class="string">"跳"</span>, <span class="string">"Rap"</span>, <span class="string">"篮球"</span>]</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>json文本中，数据以键值对的形式出现，key值必须用双引号引起，value的值根据类型不同，有以下几种：</p><ol><li>null：只有null一种</li><li>数值类型：包括整数和小数</li><li>布尔类型：true和false</li><li>字符串：需要双引号</li><li>数组：用[]包裹，其中可以是任意value的类型，多个value之间用逗号分割</li><li>对象：用{}包裹，内部可以放多个键值对，用逗号分割</li></ol><p>整个json的顶层必须是对象或者数组</p><h2 id="Python与Json"><a href="#Python与Json" class="headerlink" title="Python与Json"></a>Python与Json</h2><h3 id="Json反序列化"><a href="#Json反序列化" class="headerlink" title="Json反序列化"></a>Json反序列化</h3><p>我们获取到json文本之后，希望获得某个（某些）key值对应的value。这时我们通常需要用到python的官方json库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">txt = <span class="string">'''</span></span><br><span class="line"><span class="string">[&#123;</span></span><br><span class="line"><span class="string">    "id": 1,</span></span><br><span class="line"><span class="string">    "name": "FerlySky",</span></span><br><span class="line"><span class="string">    "admin": true,</span></span><br><span class="line"><span class="string">    "hobby": ["编程"]</span></span><br><span class="line"><span class="string">&#125;,&#123;</span></span><br><span class="line"><span class="string">    "id": 2,</span></span><br><span class="line"><span class="string">    "name": "cxk",</span></span><br><span class="line"><span class="string">    "admin": false,</span></span><br><span class="line"><span class="string">    "hobby": ["唱", "跳", "Rap", "篮球"]</span></span><br><span class="line"><span class="string">&#125;]</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">obj = json.loads(txt)</span><br><span class="line">cobj = obj[<span class="number">1</span>]</span><br><span class="line">cname = cobj[<span class="string">"name"</span>]</span><br><span class="line">chobby = cobj[<span class="string">"hobby"</span>]</span><br><span class="line"></span><br><span class="line">print(<span class="string">"name:"</span>, cname)</span><br><span class="line">print(<span class="string">"hobby:"</span>， end=<span class="string">' '</span>)</span><br><span class="line"><span class="keyword">for</span> hobby <span class="keyword">in</span> chobby:</span><br><span class="line">    print(hobby, end=<span class="string">' '</span>)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/FerlySky/PicRepository/master/20190517160052.png" alt="json.loads的结果"></p><p>其中，对象类型会被对应成python的dict，null会被对应成None</p><h3 id="Json序列化"><a href="#Json序列化" class="headerlink" title="Json序列化"></a>Json序列化</h3><p>当然，我们有时候也有可能将python的对象转换成json字符串，我们可以使用json的dumps方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">cxk = &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'cxk'</span>,</span><br><span class="line">    <span class="string">'hobby'</span>: [<span class="string">'唱'</span>, <span class="string">'跳'</span>, <span class="string">'rap'</span>, <span class="string">'篮球'</span>],</span><br><span class="line">    <span class="string">'man'</span>: <span class="literal">False</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(json.dumps(cxk, ensure_ascii=<span class="literal">False</span>))</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/FerlySky/PicRepository/master/20190517160210.png" alt="json.dumps的结果"></p><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。</p><h2 id="正则表达式语法"><a href="#正则表达式语法" class="headerlink" title="正则表达式语法"></a>正则表达式语法</h2><p>常见语法：</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>普通字符</td><td>包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号</td></tr><tr><td>转义字符</td><td>以斜线\开头的有特殊含义的字符，包括\t \r \n \\ 等，当要匹配特殊字符时需要在字符前加\</td></tr><tr><td>*</td><td>匹配前面的子表达式零次或多次</td></tr><tr><td>+</td><td>匹配前面的子表达式一次或多次</td></tr><tr><td>?</td><td>匹配前面的子表达式零次或一次</td></tr><tr><td>{n}</td><td>n 是一个非负整数。匹配确定的 n 次</td></tr><tr><td>{n,}</td><td>至少匹配n 次</td></tr><tr><td>{n,m}</td><td>最少匹配 n 次且最多匹配 m 次</td></tr><tr><td>[]</td><td>匹配中括号中的任意一个字符，[0-9] [a-zA-Z]</td></tr><tr><td>^</td><td>匹配输入字符串开始的位置</td></tr><tr><td>$</td><td>匹配输入字符串结尾的位置</td></tr><tr><td>.</td><td>匹配除换行符 \n 之外的任何单字符</td></tr></tbody></table><p>详见：<a href="https://www.runoob.com/regexp/regexp-syntax.html" rel="external nofollow noopener noreferrer" target="_blank">正则表达式 – 语法 | 菜鸟教程</a></p><p>万能匹配：(.*?)</p><h2 id="python中的正则表达式"><a href="#python中的正则表达式" class="headerlink" title="python中的正则表达式"></a>python中的正则表达式</h2><p>python为我们提供了内置的正则表达式功能，在re库中<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">html = <span class="string">'''</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">&lt;head&gt;</span></span><br><span class="line"><span class="string">    &lt;title&gt;FsBlog&lt;/title&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;ol&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;1&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;2&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;3&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;4&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li&gt;5&lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;/ol&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">title = re.search(<span class="string">'&lt;title&gt;(.*?)&lt;/title&gt;'</span>, html).group(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">lis = re.findall(<span class="string">'&lt;li&gt;(.*?)&lt;/li&gt;'</span>, html)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'title:'</span>, title)</span><br><span class="line"><span class="keyword">for</span> li <span class="keyword">in</span> lis:</span><br><span class="line">    print(<span class="string">'li:'</span>, li)</span><br></pre></td></tr></table></figure></p><p><img src="https://raw.githubusercontent.com/FerlySky/PicRepository/master/20190517155940.png" alt="正则表达式示例结果"></p><p>要获取第一个匹配到的字符串，则可以使用re.search(pattern, string, flags), 其中pattern为正则表达式，string为要被匹配的源字符串，flags为匹配参数，如果希望可以匹配多行字符串，则可以在flags处传入re.S，获得完整的匹配内容需要调用group(0)，如果想获得第几个子匹配（小括号内部匹配的内容），则可以使用group(n)</p><p>要匹配多个字符串，则可以使用re.findall(pattern, string, flags)，结果返回一个数组</p><h1 id="Xpath解析"><a href="#Xpath解析" class="headerlink" title="Xpath解析"></a>Xpath解析</h1><p>上面的正则表达式是基于文本匹配的方式获取需要的内容，它的效率比较低，而xpath方法基于dom树的解析方式效率会高很多，而且实现起来更加简单</p><p>xpath解析有局限性，只能解析xml或者类似的html等标记文档</p><p>接下来我将简单介绍xpath的术语以及其语法，当然你也可以查看<a href="https://www.runoob.com/xpath/xpath-tutorial.html" rel="external nofollow noopener noreferrer" target="_blank">XPath 教程 | 菜鸟教程</a>学习更加详细的xpath知识</p><h2 id="Xpath术语"><a href="#Xpath术语" class="headerlink" title="Xpath术语"></a>Xpath术语</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>FsBlog<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上是一个简单的html结构，其中：</p><p>节点：每个元素、属性、文本、命名空间、注释都是一个节点</p><p>根节点：文档的最外层节点，<html></html></p><p>父节点：html是head和body的父节点, head是title的父节点</p><p>子节点：head和body是html的子节点，title是head的子节点</p><p>同胞节点：head和body是同胞节点</p><p>先辈节点：父节点和父节点的父节点，html和head都是title的先辈节点</p><p>后辈节点：子节点和子节点的子节点，head、title和body都是html的后辈节点</p><h2 id="Xpath语法"><a href="#Xpath语法" class="headerlink" title="Xpath语法"></a>Xpath语法</h2><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>节点名</td><td>选取此节点的所有子节点</td></tr><tr><td>/</td><td>从根节点选取</td></tr><tr><td>//</td><td>从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置</td></tr><tr><td>.</td><td>选取当前节点</td></tr><tr><td>..</td><td>选取当前节点的父节点</td></tr><tr><td>@</td><td>选取属性</td></tr></tbody></table><p>如果想获取html节点下lang的值，可以用 //html/@lang</p><p>如果想获取title节点的内容，可以用 //title/text()</p><h2 id="Python的Xpath解析（lxml）"><a href="#Python的Xpath解析（lxml）" class="headerlink" title="Python的Xpath解析（lxml）"></a>Python的Xpath解析（lxml）</h2><p>要使用python解析xpath，需要安装一个第三方库：lxml</p><p><code>pip install lxml</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">html = <span class="string">'''</span></span><br><span class="line"><span class="string">&lt;html lang="zh"&gt;</span></span><br><span class="line"><span class="string">    &lt;head&gt;</span></span><br><span class="line"><span class="string">        &lt;title&gt;FsBlog&lt;/title&gt;</span></span><br><span class="line"><span class="string">    &lt;/head&gt;</span></span><br><span class="line"><span class="string">    &lt;body&gt;&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">tree = etree.HTML(html)</span><br><span class="line">title = tree.xpath(<span class="string">'//title/text()'</span>)[<span class="number">0</span>]</span><br><span class="line">lang = tree.xpath(<span class="string">'//html/@lang'</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">print(<span class="string">'title:'</span>, title)</span><br><span class="line">print(<span class="string">'lang:'</span>, lang)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/FerlySky/PicRepository/master/20190517164438.png" alt="Xpath解析结果"></p><p>先从lxml库中导出etree，使用etree.HTML()函数创建dom树对象</p><p>调用tree的xpath(xpath)方法，获取所有匹配到的内容，返回一个数组</p><h1 id="使用CSS选择器解析"><a href="#使用CSS选择器解析" class="headerlink" title="使用CSS选择器解析"></a>使用CSS选择器解析</h1><p>这种方式是采用css选择元素的方式一致，非常适合对css有所了解的人</p><h2 id="css选择器语法"><a href="#css选择器语法" class="headerlink" title="css选择器语法"></a>css选择器语法</h2><table><thead><tr><th>选择器</th><th>描述</th></tr></thead><tbody><tr><td>.class</td><td>类选择器</td></tr><tr><td>#id</td><td>id选择器</td></tr><tr><td>*</td><td>全选</td></tr><tr><td>element</td><td>匹配所有指定元素名的元素</td></tr><tr><td>a, b</td><td>匹配a选择器或b选择器中的任意一个即可匹配</td></tr><tr><td>a b</td><td>匹配a的后辈中的b</td></tr><tr><td>a&gt;b</td><td>匹配a的子元素b</td></tr><tr><td>a+b</td><td>匹配a紧跟着的兄弟b</td></tr><tr><td>[attr]</td><td>匹配具有特定属性的元素</td></tr><tr><td>[attr=val]</td><td>匹配具有指定属性并且值为指定值的元素</td></tr></tbody></table><p>详细的css选择器，查看<a href="https://www.runoob.com/cssref/css-selectors.html" rel="external nofollow noopener noreferrer" target="_blank">CSS 选择器 | 菜鸟教程</a></p><p>注意：伪类 :link :active :hover :focus :visited 并不能匹配元素</p><h2 id="Python使用css选择器解析文档（BeautifulSoup）"><a href="#Python使用css选择器解析文档（BeautifulSoup）" class="headerlink" title="Python使用css选择器解析文档（BeautifulSoup）"></a>Python使用css选择器解析文档（BeautifulSoup）</h2><p>在python中使用css选择器解析文档需要安装一个第三方库：BeautifulSoup<br><code>pip install BeautifulSoup4</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">html = <span class="string">'''</span></span><br><span class="line"><span class="string">&lt;html lang="zh"&gt;</span></span><br><span class="line"><span class="string">    &lt;head&gt;</span></span><br><span class="line"><span class="string">        &lt;title&gt;FsBlog&lt;/title&gt;</span></span><br><span class="line"><span class="string">    &lt;/head&gt;</span></span><br><span class="line"><span class="string">    &lt;body&gt;&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(html, <span class="string">'html.parser'</span>)</span><br><span class="line">title = soup.title.text</span><br><span class="line">lang = soup.html[<span class="string">'lang'</span>]</span><br><span class="line"></span><br><span class="line">print(<span class="string">'title:'</span>, title)</span><br><span class="line">print(<span class="string">'lang:'</span>, lang)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/FerlySky/PicRepository/master/20190517164438.png" alt="BeautifulSoup解析结果"></p><p>其中BeautifulSoup构造方法的第二个参数是解析器，可选的参数及优缺点如下：<br><img src="https://raw.githubusercontent.com/FerlySky/PicRepository/master/20190517170955.png" alt="BeautifulSoup解析器"></p><p><a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/" rel="external nofollow noopener noreferrer" target="_blank">BeautifulSoup官方中文文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一节中，我们学会了使用requests库从网上请求数据，但是我们发现请求的数据很多时候是html页面，页面中有用的内容往往只有其中的一小部分，所以我们就需要在很大的文本（通常是html）中提取出对我们最有用的内容&lt;/p&gt;
&lt;p&gt;在这一小节，我们会了解到如何解析json、如何使用正则表达式解析文本，以及使用xpath和css选择器解析html文档&lt;/p&gt;
    
    </summary>
    
      <category term="网络爬虫" scheme="https://ferlysky.gitee.io/categories/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="python" scheme="https://ferlysky.gitee.io/tags/python/"/>
    
      <category term="spider" scheme="https://ferlysky.gitee.io/tags/spider/"/>
    
      <category term="网络爬虫" scheme="https://ferlysky.gitee.io/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    
      <category term="文本解析" scheme="https://ferlysky.gitee.io/tags/%E6%96%87%E6%9C%AC%E8%A7%A3%E6%9E%90/"/>
    
      <category term="json" scheme="https://ferlysky.gitee.io/tags/json/"/>
    
      <category term="xpath" scheme="https://ferlysky.gitee.io/tags/xpath/"/>
    
      <category term="正则表达式" scheme="https://ferlysky.gitee.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="css selector" scheme="https://ferlysky.gitee.io/tags/css-selector/"/>
    
      <category term="lxml" scheme="https://ferlysky.gitee.io/tags/lxml/"/>
    
      <category term="BeautifulSoup4" scheme="https://ferlysky.gitee.io/tags/BeautifulSoup4/"/>
    
  </entry>
  
  <entry>
    <title>Python Spider 2: 网络请求</title>
    <link href="https://ferlysky.gitee.io/python-spider-2.html"/>
    <id>https://ferlysky.gitee.io/python-spider-2.html</id>
    <published>2019-04-08T13:59:47.000Z</published>
    <updated>2019-05-08T05:56:02.061Z</updated>
    
    <content type="html"><![CDATA[<p>要想分析到有用的数据，我们首先要先获取到网络资源，其中最主要的就是网页和json</p><p>浏览器在获取资源时，实际上是向浏览器发送了http请求</p><p>这一章中我们会了解如何手动发送http请求获取资源，以及如何用已有的框架（requests）获取资源</p><a id="more"></a><h1 id="建立Tcp连接模拟Http请求"><a href="#建立Tcp连接模拟Http请求" class="headerlink" title="建立Tcp连接模拟Http请求"></a>建立Tcp连接模拟Http请求</h1><p>http请求的本质是一个tcp请求，只是传输数据的格式比较特殊。</p><h2 id="Http请求报文解析"><a href="#Http请求报文解析" class="headerlink" title="Http请求报文解析"></a>Http请求报文解析</h2><p>http请求报文由3部分组成：请求行，请求头，请求体。其中某些请求方式可能没有请求体。</p><p>下面是一个http post的请求报文：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/weapi/search/suggest/web?csrf_token=</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: music.163.com</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">Content-Length</span>: 394</span><br><span class="line"><span class="attribute">Pragma</span>: no-cache</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-cache</span><br><span class="line"><span class="attribute">Origin</span>: https://music.163.com</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Accept</span>: */*</span><br><span class="line"><span class="attribute">Referer</span>: https://music.163.com/</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate, br</span><br><span class="line"><span class="attribute">Accept-Language</span>: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7</span><br><span class="line"><span class="attribute">Cookie</span>: starttime=;</span><br><span class="line"></span><br><span class="line">params=tZA39GIzuYfZGwabdxUe3OtRtEj8BqfGyk95pyloHT3iIsxUfDmEC60V1rxn0DHfvKVnXrACICP6ZV7a8wQC74RO%2BHPxDM%2FlwiYU%2B%2BwS%2Bf8%3D&amp;encSecKey=8bf98f9a88662ac9606ff2c9336a23f6d9e7413cb3c6c9c2ef56eeec2e814ead675a032c9905b21526bd8ed59aa0862d0114d78629f954f47276cb3f2a9987faf49add6b5c289776c23329cada89afbb51e6e5c756c637be364a695013c1029da680894766a234656a667991cd580c8cd047160de48e0ff9982437826d374524</span><br></pre></td></tr></table></figure></p><p>第一行为请求行：<code>POST /weapi/search/suggest/web?csrf_token= HTTP/1.1</code>，由三部分组成，请求方式，请求路径和协议版本</p><ul><li>请求方式：爬虫最常见的请求方式为GET方式和POST方式，除此之外还有DELETE，PUT，HEAD等</li><li>请求路径：请求路径是一个uri，是相对服务器项目根路径下的地址</li><li>协议版本：HTTP1.0和HTTP1.1，其中1.0每完成一次请求都会断开连接，而HTTP1.1会保持连接一段时间</li></ul><p>从第二行开始，到空行结束的部分为请求头。表示请求时的一些请求通用参数，它的本质为一个Map，其中请求头的key有固定的含义，不区分大小写</p><p>第三部分为请求体，不同的请求类型，请求体的格式也不同，常见为key-value形式，用于表示参数，key和value之间用’=’连接，参数之间用’&amp;’连接</p><p>注意请求头和请求体之间有一个空行，请求体结束也需要一个空行</p><h2 id="Http响应报文解析"><a href="#Http响应报文解析" class="headerlink" title="Http响应报文解析"></a>Http响应报文解析</h2><p>响应报文和请求报文一样，由响应行，响应头和响应体组成<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Accept-Ranges</span>: bytes</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-cache</span><br><span class="line"><span class="attribute">Content-Length</span>: 14615</span><br><span class="line"><span class="attribute">Content-Type</span>: text/html</span><br><span class="line"><span class="attribute">Date</span>: Mon, 15 Apr 2019 10:34:52 GMT</span><br><span class="line"><span class="attribute">Etag</span>: "5c9c7bd5-3917"</span><br><span class="line"><span class="attribute">Last-Modified</span>: Thu, 28 Mar 2019 07:46:29 GMT</span><br><span class="line"><span class="attribute">P3p</span>: CP=" OTI DSP COR IVA OUR IND COM "</span><br><span class="line"><span class="attribute">Pragma</span>: no-cache</span><br><span class="line"><span class="attribute">Server</span>: BWS/1.1</span><br><span class="line"><span class="attribute">Set-Cookie</span>: BAIDUID=71A25E6D0916916E940A4FCA7B0D87C6:FG=1; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com</span><br><span class="line"><span class="attribute">Set-Cookie</span>: BIDUPSID=71A25E6D0916916E940A4FCA7B0D87C6; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com</span><br><span class="line"><span class="attribute">Set-Cookie</span>: PSTM=1555324492; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com</span><br><span class="line"><span class="attribute">Vary</span>: Accept-Encoding</span><br><span class="line"><span class="attribute">X-Ua-Compatible</span>: IE=Edge,chrome=1</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;</span><br><span class="line">&lt;meta http-equiv="X-UA-Compatible" content="IE=Edge"&gt;</span><br><span class="line">&lt;link rel="dns-prefetch" href="//s1.bdstatic.com"/&gt;</span><br></pre></td></tr></table></figure></p><p>响应行由三部分组成，协议版本，响应状态码，响应消息。其中响应消息和相应状态码通常相对应</p><p>HTTP状态码分类：</p><table><thead><tr><th>分类</th><th>分类描述</th></tr></thead><tbody><tr><td>1xx</td><td>表示服务器收到了请求，需要请求者继续发送请求</td></tr><tr><td>2xx</td><td>表示操作成功</td></tr><tr><td>3xx</td><td>重定向，表示需要进一步操作</td></tr><tr><td>4xx</td><td>客户端错误，表示语法错误或无法完成请求</td></tr><tr><td>5xx</td><td>服务端错误，表示服务器在处理请求的过程中发生了错误</td></tr></tbody></table><p>常见的状态码：</p><table><thead><tr><th>状态码</th><th>消息</th><th>描述</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td>请求成功</td></tr><tr><td>302</td><td>REDIRECT</td><td>暂时的重定向</td></tr><tr><td>400</td><td>BAD REQUEST</td><td>请求错误</td></tr><tr><td>404</td><td>NOT FOUND</td><td>资源未找到</td></tr><tr><td>500</td><td>Internal Server Error</td><td>服务器错误</td></tr></tbody></table><p>响应头与请求头一样，都是有固定一样的键值参数</p><p>响应体就是与我们请求时的uri和参数的资源啦。</p><h2 id="使用python发送http请求"><a href="#使用python发送http请求" class="headerlink" title="使用python发送http请求"></a>使用python发送http请求</h2><p>我们这里以请求百度的主页为例，看一下如何使用tcp来发送http请求<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  <span class="comment"># 创建socket对象</span></span><br><span class="line">    client.connect((<span class="string">'www.baidu.com'</span>, <span class="number">80</span>))  <span class="comment"># 连接百度服务器，http请求默认为80端口</span></span><br><span class="line">    request_line = <span class="string">'GET / HTTP/1.0'</span>  <span class="comment"># 请求行</span></span><br><span class="line">    request_header = <span class="string">'HOST: www.baidu.com'</span>  <span class="comment"># 请求头</span></span><br><span class="line">    request_body = <span class="string">''</span>  <span class="comment"># 请求体</span></span><br><span class="line">    <span class="comment"># 拼接请求字符串</span></span><br><span class="line">    <span class="keyword">if</span> len(request_body) &gt; <span class="number">0</span>:</span><br><span class="line">        request_text = <span class="string">'\r\n'</span>.join([request_line, request_header, request_body, <span class="string">''</span>]) + <span class="string">'\r\n'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        request_text = <span class="string">'\r\n'</span>.join([request_line, request_header]) + <span class="string">'\r\n\r\n'</span></span><br><span class="line">    print(request_text)  <span class="comment"># 输出请求报文</span></span><br><span class="line">    client.send(request_text.encode())  <span class="comment"># 发送请求报文</span></span><br><span class="line">    print(<span class="string">'*'</span> * <span class="number">150</span>)  <span class="comment"># 分割线</span></span><br><span class="line">    <span class="comment"># 获取相应报文</span></span><br><span class="line">    data = <span class="string">b''</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        rec_data = client.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> rec_data:</span><br><span class="line">            data += rec_data</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    print(data.decode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure></p><p><img src="https://raw.githubusercontent.com/FerlySky/PicRepository/master/20190508135516.png" alt="Tcp请求结果"></p><h2 id="Tcp方式的缺点"><a href="#Tcp方式的缺点" class="headerlink" title="Tcp方式的缺点"></a>Tcp方式的缺点</h2><p>在实际爬虫或其他http请求需求的时候，我们很少会用tcp方式发送http请求，因为它有很多缺点</p><ul><li>需要手动构建请求路径uri，手动构建uri的请求参数，并且在需要时进行url编码</li><li>需要手动拼接请求头</li><li>传递参数或者上传文件（图片）等资源时需要手动处理</li><li>解析响应报文非常复杂且容易出错</li><li>很难使用代理服务器发送请求</li></ul><h1 id="requests"><a href="#requests" class="headerlink" title="requests"></a>requests</h1><p>由于Tcp发送http请求的方式有很多缺点，所以我们通常会使用一些http请求的框架来帮我们解决这些问题。而在python中，最常见的http请求库就是requests</p><p>由于requests是第三方库，所以我们在使用requests之前，需要先安装它：<code>pip install requests</code></p><p>引入requests：<code>import requests</code></p><p>快速入门：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    resp = requests.get(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line">    print(resp.text)</span><br></pre></td></tr></table></figure></p><h2 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h2><p>发送不同的请求方式的请求，可以直接调用对应的方法即可<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">response = requests.get(<span class="string">'https://api.github.com/events'</span>)</span><br><span class="line">response = requests.post(<span class="string">'http://httpbin.org/post'</span>, data = &#123;<span class="string">'key'</span>:<span class="string">'value'</span>&#125;)</span><br><span class="line">response = requests.put(<span class="string">'http://httpbin.org/put'</span>, data = &#123;<span class="string">'key'</span>:<span class="string">'value'</span>&#125;)</span><br><span class="line">response = requests.delete(<span class="string">'http://httpbin.org/delete'</span>)</span><br><span class="line">response = requests.head(<span class="string">'http://httpbin.org/get'</span>)</span><br><span class="line">response = requests.options(<span class="string">'http://httpbin.org/get'</span>)</span><br></pre></td></tr></table></figure></p><p>由于post和put方法往往需要传递参数，可以直接传递data这个命名参数，类型为map类型</p><h3 id="url参数"><a href="#url参数" class="headerlink" title="url参数"></a>url参数</h3><p>有些时候我们需要在通过url传递参数，我们可以使用params参数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">params = &#123;</span><br><span class="line">    <span class="string">'ie'</span>: <span class="string">'UTF-8'</span>,</span><br><span class="line">    <span class="string">'word'</span>: <span class="string">'test'</span></span><br><span class="line">&#125;</span><br><span class="line">url = <span class="string">'https://www.baidu.com/s'</span></span><br><span class="line">response = requests.get(url,params=params)</span><br></pre></td></tr></table></figure></p><p>这时，我们get的真实url为：<code>https://www.baidu.com/s?ie=UTF-8&amp;wd=test</code></p><h3 id="自定义请求头"><a href="#自定义请求头" class="headerlink" title="自定义请求头"></a>自定义请求头</h3><p>在请求的时候，我们往往需要模拟Host或Origin请求头来进行模拟跨域操作，需要使用到headers<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'Accept'</span>: <span class="string">'*/*'</span>,</span><br><span class="line">    <span class="string">'Host'</span>: <span class="string">'www.baidu.com'</span></span><br><span class="line">&#125;</span><br><span class="line">url = <span class="string">'https://www.baidu.com/'</span></span><br><span class="line">response = requests.get(url, headers=headers)</span><br></pre></td></tr></table></figure></p><h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><p>有些时候我们可能需要上传某些文件，比如修改头像等，我们可以使用files参数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">files = &#123;<span class="string">'file'</span>: open(<span class="string">'avatar.png'</span>, <span class="string">'rb'</span>)&#125;</span><br><span class="line">url = <span class="string">'http://httpbin.org/post'</span></span><br><span class="line">response = requests.post(url, files=files)</span><br></pre></td></tr></table></figure></p><h2 id="获取响应"><a href="#获取响应" class="headerlink" title="获取响应"></a>获取响应</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'text'</span>, response.text)  <span class="comment"># 获取响应文本，类型为str</span></span><br><span class="line">print(<span class="string">'content'</span>, response.content)  <span class="comment"># 获取响应内容，类型为bytes</span></span><br><span class="line">print(<span class="string">'json'</span>, response.json())  <span class="comment"># 将响应内容当作json字符串解析</span></span><br><span class="line">print(<span class="string">'status code'</span>, response.status_code)  <span class="comment"># 获取响应状态码</span></span><br><span class="line">print(<span class="string">'encoding'</span>, response.encoding)  <span class="comment"># 获取编码格式</span></span><br><span class="line">print(<span class="string">'headers'</span>, response.headers)  <span class="comment"># 获取响应头</span></span><br></pre></td></tr></table></figure><p>修改响应编码格式：<code>response.encoding = &#39;UTF-8&#39;</code>，先修改完编码格式，在通过<code>response.text</code>即可获取UTF-8（或其他）编码格式下的响应文本</p><h2 id="流式请求"><a href="#流式请求" class="headerlink" title="流式请求"></a>流式请求</h2><p>有时我们请求的资源不一定都是文本类型，有可能是图片，视频，音乐等文件类型，这些文件通常比较大，虽然可以使用上面的普通方式，通过<code>response.content</code>获取二进制字符集，但是我们使用数据流的方式能更方便的处理大型文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chunk_size = <span class="number">1024</span> * <span class="number">16</span>  <span class="comment"># 声明数据块大小</span></span><br><span class="line">response = requests.get(<span class="string">'https://ferlysky.gitee.io/images/avatar.png'</span>, stream=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'avatar.png'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># 迭代数据块，并写入到文件中</span></span><br><span class="line">    <span class="keyword">for</span> chunk <span class="keyword">in</span> response.iter_content(chunk_size):</span><br><span class="line">        f.write(chunk)</span><br></pre></td></tr></table></figure><p>这里用到了文件io，我会在后面的章节进行讲解</p><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>爬虫时，我们往往会被网站的反爬机制限制ip访问，这时我们可以使用代理服务器来解决</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">proxies = &#123;</span><br><span class="line">    <span class="string">"http"</span>: <span class="string">"http://10.10.1.10:3128"</span>,</span><br><span class="line">    <span class="string">"https"</span>: <span class="string">"http://10.10.1.10:1080"</span>,</span><br><span class="line">&#125;</span><br><span class="line">requests.get(<span class="string">"http://example.org"</span>, proxies=proxies)</span><br></pre></td></tr></table></figure><h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>在我们进行请求的时候，有时需要我们传递cookies(例如登录之后才能进行的操作)</p><h3 id="手动cookies"><a href="#手动cookies" class="headerlink" title="手动cookies"></a>手动cookies</h3><p>请求时携带cookies<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jar = requests.cookies.RequestsCookieJar()</span><br><span class="line">jar.set(<span class="string">'name'</span>, <span class="string">'FerlySky'</span>)</span><br><span class="line">jar.set(<span class="string">'url'</span>, <span class="string">'https://ferlysky.gitee.io'</span>)</span><br><span class="line">url = <span class="string">'http://httpbin.org/cookies'</span></span><br><span class="line">response = requests.get(url, cookies=jar)</span><br><span class="line">print(response.json())</span><br></pre></td></tr></table></figure></p><p>获取响应cookies<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'cookies'</span>, response.cookies)</span><br></pre></td></tr></table></figure></p><h3 id="自动携带cookies"><a href="#自动携带cookies" class="headerlink" title="自动携带cookies"></a>自动携带cookies</h3><p>每次都需要手动设置cookies，并且把响应的cookies拿出来再次设置到下次请求中实在是太麻烦了，requests库给我们提供了一种简单的方法，就是使用session对象</p><p>使用session对象，可以将我们上一次请求时响应的cookies保存下来，在下一次请求时发送出去</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">session = requests.session()</span><br><span class="line"></span><br><span class="line">response = session.get(<span class="string">'http://www.baidu.com/'</span>)</span><br><span class="line">print(response.cookies[<span class="string">'BDORZ'</span>])</span><br></pre></td></tr></table></figure><p>session的操作和requests几乎完全一致</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;要想分析到有用的数据，我们首先要先获取到网络资源，其中最主要的就是网页和json&lt;/p&gt;
&lt;p&gt;浏览器在获取资源时，实际上是向浏览器发送了http请求&lt;/p&gt;
&lt;p&gt;这一章中我们会了解如何手动发送http请求获取资源，以及如何用已有的框架（requests）获取资源&lt;/p&gt;
    
    </summary>
    
      <category term="网络爬虫" scheme="https://ferlysky.gitee.io/categories/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="python" scheme="https://ferlysky.gitee.io/tags/python/"/>
    
      <category term="spider" scheme="https://ferlysky.gitee.io/tags/spider/"/>
    
      <category term="网络爬虫" scheme="https://ferlysky.gitee.io/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    
      <category term="网络请求" scheme="https://ferlysky.gitee.io/tags/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
    
      <category term="http" scheme="https://ferlysky.gitee.io/tags/http/"/>
    
      <category term="requests" scheme="https://ferlysky.gitee.io/tags/requests/"/>
    
      <category term="tcp" scheme="https://ferlysky.gitee.io/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>Python Spider 1: 概述</title>
    <link href="https://ferlysky.gitee.io/python-spider-1.html"/>
    <id>https://ferlysky.gitee.io/python-spider-1.html</id>
    <published>2019-04-07T14:07:09.000Z</published>
    <updated>2019-04-18T14:14:27.455Z</updated>
    
    <content type="html"><![CDATA[<p>随着大数据时代的到来，人们对数据资源的需求越来越多，而爬虫是一种很好的自动采集数据的手段。</p><h1 id="网络爬虫"><a href="#网络爬虫" class="headerlink" title="网络爬虫"></a>网络爬虫</h1><blockquote><p>网络爬虫（又被称为网页蜘蛛，网络机器人，在FOAF社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。</p></blockquote><a id="more"></a><h1 id="爬虫的分类及应用"><a href="#爬虫的分类及应用" class="headerlink" title="爬虫的分类及应用"></a>爬虫的分类及应用</h1><p>爬虫按照系统结构和实现技术大致可以分为：通用网络爬虫、聚焦网络爬虫 、增量式网络爬虫和深层网络爬虫。</p><ul><li>通用网络爬虫：通用爬虫的目标是尽可能大的网络覆盖。由于其数据涵盖范围较广，很多时候并不能获取到比较专业的资源。像百度谷歌等搜索引擎就是典型的通用爬虫。</li><li>聚焦网络爬虫：它根据要爬取的目标，有选择性的获取互联网上的资源，其结果更具有针对性。</li><li>增量式网络爬虫：只爬取新产生的或者发生变化的网页，不爬取已经获取过的资源。可以减小时间、空间以及带宽的消耗，但是实现起来相对复杂</li><li>深层网络爬虫：爬取某些非表面显示的资源，比如需要登录账号才能查看的资源。</li></ul><h1 id="爬虫的工作流程"><a href="#爬虫的工作流程" class="headerlink" title="爬虫的工作流程"></a>爬虫的工作流程</h1><ol><li>首先选取一部分精心挑选的种子URL；</li><li>将这些URL放入待抓取URL队列；</li><li>从待抓取URL队列中取出待抓取在URL，解析DNS，并且得到主机的ip，并将URL对应的网页下载下来，存储进已下载网页库中。此外，将这些URL放进已抓取URL队列。</li><li>分析已抓取URL队列中的URL，分析其中的其他URL，并且将URL放入待抓取URL队列，从而进入下一个循环。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着大数据时代的到来，人们对数据资源的需求越来越多，而爬虫是一种很好的自动采集数据的手段。&lt;/p&gt;
&lt;h1 id=&quot;网络爬虫&quot;&gt;&lt;a href=&quot;#网络爬虫&quot; class=&quot;headerlink&quot; title=&quot;网络爬虫&quot;&gt;&lt;/a&gt;网络爬虫&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;网络爬虫（又被称为网页蜘蛛，网络机器人，在FOAF社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="网络爬虫" scheme="https://ferlysky.gitee.io/categories/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="python" scheme="https://ferlysky.gitee.io/tags/python/"/>
    
      <category term="spider" scheme="https://ferlysky.gitee.io/tags/spider/"/>
    
      <category term="网络爬虫" scheme="https://ferlysky.gitee.io/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    
      <category term="概述" scheme="https://ferlysky.gitee.io/tags/%E6%A6%82%E8%BF%B0/"/>
    
  </entry>
  
  <entry>
    <title>算法 1: 动态规划</title>
    <link href="https://ferlysky.gitee.io/algorithm-1.html"/>
    <id>https://ferlysky.gitee.io/algorithm-1.html</id>
    <published>2019-03-29T14:22:16.000Z</published>
    <updated>2019-05-08T05:59:03.483Z</updated>
    
    <content type="html"><![CDATA[<p>动态规划是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。</p><p>动态规划常常适用于有重叠子问题和最优子结构性质的问题。<br><a id="more"></a></p><h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><p>若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。</p><p>动态规划的核心是：<strong>记忆已经解决的子问题的解</strong></p><h1 id="问题特征"><a href="#问题特征" class="headerlink" title="问题特征"></a>问题特征</h1><p>动态规划的基本特征：问题的最优解需要使用到其子问题的最优解</p><h1 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h1><ol><li>分析最优解的结构：将问题划分成两个子问题，如果原问题获得最优解，子问题也应该是最优解。</li><li>建立递推关系</li><li>计算最优解</li></ol><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="最长回文子串问题"><a href="#最长回文子串问题" class="headerlink" title="最长回文子串问题"></a>最长回文子串问题</h2><ol><li>问题：给定一个字符串s，找到s中最长的回文子串。（选自Leetcode #5）</li><li>分析解结构：<br> 如果一个字符串是回文串，那么它去掉收尾后也应该是回文串。那么我们就可以讲问题转化为先找到一个小的回文串，然后在判断该回文串在原字符串中前后两个字符是否相同，如果相同，将该子回文串的前后都添加这个字符，新的字符串仍是回文串。</li><li><p>建立递推关系：<br> 设 i, j为字符串s的某一子字符串s[i:j]的开始索引和结束索引，i &lt;= j，我们可以使用一个二维的bool数组 b 来记录位置 b[i][j] 对应的子字符串 s[i:j] 是否为回文串。</p><ol><li>如果 i == j, 说明s[i:j]为单个字符，必定是一个回文串</li><li>如果 j - i == 1, 说明s[i:j]是一个长度为2的字符串，如果 s[i] == s[j], 则s[i:j]是一个回文串</li><li><p>如果 i, j 不满足前两条，说明s[i:j]是一个长度大于等于3的字符串，它可以由它去掉两端的字串s[i+1:j-1]，拼接两个字符 s[i], s[j] 来解决，如果 s[i+1:j-1] 是一个回文串，同时 s[i] == s[j], 则s[i:j]是一个回文串</p><p>用公式表示为：<br><img src="https://raw.githubusercontent.com/FerlySky/PicRepository/master/20190508135847.png" alt="最长回文子串问题公式表示"></p><p>我们以 s = “atrattardd” 为例，画出二维数组：<br><img src="https://raw.githubusercontent.com/FerlySky/PicRepository/master/20190508135817.png" alt="最长回文子串问题示例矩阵"></p><p>我们可以清晰的发现，如果一个位置为0，那么它右上方的位置一定为0，并且要获取最长回文子串，只需要找到矩阵中，离右上角最近的1的位置即可。对于该示例而言，最长回文子串的位置为s[2:7] = “rattar”</p></li></ol></li><li>算法实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="comment">// 用来记录对应子串是否为回文子串</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] bmap = <span class="keyword">new</span> <span class="keyword">boolean</span>[length][length];</span><br><span class="line">        <span class="comment">// 用来记录长度的最大值</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 为了保证在计算某一位置之前，其最下方位置已经被计算并保存过，所以这里i从下往上遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &lt; length; j++) &#123; <span class="comment">// &amp;&amp; j &lt; length</span></span><br><span class="line">                <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                    bmap[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j - i == <span class="number">1</span>) &#123;</span><br><span class="line">                    bmap[i][j] = chars[i] == chars[j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    bmap[i][j] = bmap[i+<span class="number">1</span>][j-<span class="number">1</span>] &amp;&amp; chars[i] == chars[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (bmap[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; max) &#123;</span><br><span class="line">                    max = j - i + <span class="number">1</span>;</span><br><span class="line">                    start = i;</span><br><span class="line">                    end = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start, end + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;动态规划是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。&lt;/p&gt;
&lt;p&gt;动态规划常常适用于有重叠子问题和最优子结构性质的问题。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="https://ferlysky.gitee.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="algorithm" scheme="https://ferlysky.gitee.io/tags/algorithm/"/>
    
      <category term="算法" scheme="https://ferlysky.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="https://ferlysky.gitee.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Flutter Plugins 1: Fluttertoast</title>
    <link href="https://ferlysky.gitee.io/flutter-plugin-1.html"/>
    <id>https://ferlysky.gitee.io/flutter-plugin-1.html</id>
    <published>2019-03-28T04:31:45.000Z</published>
    <updated>2019-04-18T14:14:27.455Z</updated>
    
    <content type="html"><![CDATA[<p>Fluttertoast 是一个弹出toast的第三方框架<br><a id="more"></a></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line"><span class="attr">  fluttertoast:</span> <span class="string">^3.0.3</span></span><br></pre></td></tr></table></figure><p>获取最新版本号：<a href="https://pub.flutter-io.cn/packages/fluttertoast" rel="external nofollow noopener noreferrer" target="_blank">https://pub.flutter-io.cn/packages/fluttertoast</a></p><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><h2 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:fluttertoast/fluttertoast'</span>;</span><br></pre></td></tr></table></figure><h2 id="弹出toast"><a href="#弹出toast" class="headerlink" title="弹出toast"></a>弹出toast</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Fluttertoast.showToast(</span><br><span class="line">  msg: <span class="string">"This is Center Short Toast"</span>,</span><br><span class="line">  toastLength: Toast.LENGTH_SHORT,</span><br><span class="line">  gravity: ToastGravity.CENTER,</span><br><span class="line">  timeInSecForIos: <span class="number">1</span>,</span><br><span class="line">  backgroundColor: Colors.red,</span><br><span class="line">  textColor: Colors.white,</span><br><span class="line">  fontSize: <span class="number">16.0</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>参数:</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>msg</td><td>String，要弹出的消息，非空必须</td></tr><tr><td>toastLength</td><td>Toast.LENGTH_SHORT、 Toast.LENGTH_LONG</td></tr><tr><td>gravity</td><td>ToastGravity，toast显示的位置，ToastGravity.TOP、ToastGravity.CENTER、ToastGravity.BOTTOM</td></tr><tr><td>timeInSecForIos</td><td>int，仅限ios平台</td></tr><tr><td>backgroundColor</td><td>Color，背景颜色</td></tr><tr><td>textColor</td><td>Color，文字颜色</td></tr><tr><td>fontSize</td><td>float，文字大小</td></tr></tbody></table><h2 id="取消弹出"><a href="#取消弹出" class="headerlink" title="取消弹出"></a>取消弹出</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fluttertoast.cancel();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Fluttertoast 是一个弹出toast的第三方框架&lt;br&gt;
    
    </summary>
    
      <category term="Flutter" scheme="https://ferlysky.gitee.io/categories/Flutter/"/>
    
      <category term="Flutter Plugins" scheme="https://ferlysky.gitee.io/categories/Flutter/Flutter-Plugins/"/>
    
    
      <category term="Flutter" scheme="https://ferlysky.gitee.io/tags/Flutter/"/>
    
      <category term="Flutter Plugin" scheme="https://ferlysky.gitee.io/tags/Flutter-Plugin/"/>
    
  </entry>
  
</feed>
